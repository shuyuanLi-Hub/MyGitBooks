* Java是一门强类型（strong type）的语言。
  * 所有变量必须先声明，后使用。
  * 指定类型的变量，只能装相应类型的值。
  * 缺点：编程比较繁琐，总要关注数据类型。
  *  优点：程序会更安全，健壮。

* 声明变量：
  * 标识符：用于给程序中各种东西起名字。
    * 语法规则：只能是字母（英文，中文，日文，韩文……），数字，下划线，$组成，数字不能开头，也不能是Java的关键字。

* Java的关键字：48个。教材p48页，表3.1
  * 【面试题】：还有两个保留字：<dfn>const</dfn>，<dfn>goto</dfn>，属于暂时没有使用，以后可能使用的关键字。
    三个直接量：true,false,null,也不能作为变量名。

* Java是区分大小写，所有关键字的字母全部是小写。java的类名，每个单词首字母都是大写。

* 类型：

  * ```java
    		 ↗ 基本类型(8个)
    Java类型
    		 ↘ 引用类型(类，接口，枚举，数组)
    ```

  * String:代表字符串，属于JDK提供的类。

* 整型:
  * 位（bit）:要么是0，要么是1。
  * 字节（byte）:8个bit。

| 2^0=1   | 2^1=2     | 2^2=4     | 2^3=8     | 2^4=16     | 2^5=32 | 2^6=64       | 2^7=128 | 2^8=256 |
| ------- | --------- | --------- | --------- | ---------- | ------ | ------------ | ------- | ------- |
| 2^9=512 | 2^10=1024 | 2^11=2048 | 2^12=4096 | 2^16=65536 | 2^20=M | 2^30=G(十亿) | 2^40=T  |         |

▲ Java的整型，一共有四个：
byte:	1个字节 8位  （能表示256个数），取值范围：-128~127
short:	2个字节 16位（能表示65536个数），取值范围：-32768~32767
<dfn>int</dfn>:	4个字节 32位（能表示4G个数），取值范围：-2G~2G-1
long:	8个字节 64位  取值范围很大，无需记忆

▲ 整型的注意点：

A.你直接给出一个整数，整数默认是<dfn>int</dfn>型。
    如果该整数值较小，且直接赋值给byte或short，java也可以将它当成byte,short处理。

B.如果你直接给出一个巨大的整数，java不会自动把它当成long型处理。
   如果希望java把该整型当成long处理，需要在整数后添加L或l后缀。

C.整数一共有4种表示形式。

   十进制：
   八进制：以0开头。
	逢8进一，只能出现0~7.
   十六进制：以0x开头，或0X开头。
	逢16进一，只能出现0~9，a~f.
   二进制：以0B或0b开头。
	逢2进1，只能出现0~1
   十六进制的数，在编程中非常常用--每位十六进制的数，恰好换算成4位二进制数，因此非常方便。

★ 浮点型：
	只能装带小数部分的数。
	

▲ Java的浮点型，一共有两个：

float:4个字节（32位）：取值更大
double: 8个字节（64位）：取值超大。

Q1：编程时应该用float?还是double?为什么？
A1：应该用double.
        浮点数都有精度丢失，但float丢失的更严重。
        因为现在的内存已经非常便宜，出于精度考虑，应该使用double.

▲ 浮点型的注意点：
A.直接给出一个浮点值，默认是double型。
   如果你希望一个浮点值被当成float处理，必须在浮点值添加F或f.

B.浮点数会有精度丢失。
   所以浮点数比较时，应该用“差值法”。

C.浮点数有两种表示形式。

   -小数形式。
   -科学计数法。数eN = 数 * 10^N
    只要用科学计数法，就一定是浮点数，不可能是整数。

D.浮点值有三个特殊值：
   浮点数除以0，得到无穷大。
   正无穷大：正正得正，负负得正
   负无穷大：正负得负
      【所有正无穷大都相等；所有负无穷大都相等】
   非数：浮点0除以0，对负数开方，得到的就是非数。<dfn>NaN</dfn>(Not a Number)
      【非数与任何数都不相等，与它自己都不相等】

★ 字符型：
	只能装单个字符（英文，中文，日文，韩文……），且单个字符要放在单引号里。

char:2个字节（16位）。

▲字符型的注意点：

A.字符型有三种表示形式：
   - 单引号里放普通字符。

   -单引号里放特殊的转义字符。
     Java的转义参考教材P52,表3.2

   - 用字符的Unicode编号，十六进制。

B.字符完全可以当成无符号整数使用。
   字符当成无符号整数使用时，其实就是用该字符的编号。

Java类型可分为两大类：数值型（整型，浮点型，字符型）

/********************************************************
字符集：为了在计算机底层保存字符，为所有字符编号，
             需要保存字符时，实际上保存该字符的编号（二进制）
             读取字符内容时，读取的是二进制的编号，还需要参照编号表才能得到对应的字符。

 ASCII:只支持英文，数字，标点符号。
a-z: 97~97+25 ; A-Z:65~90 ; 0~9: 48~57
\r: 13 ; \n: 10 ; ‘ : 39 ; " : 34
 GB2312:简体中文字符集
 GBK:简体中文字符集
 GB18030:目前简体的字符集

 所谓字符集：就是为所有的字符编号。

 美国人制定了兼容全球所有国家文字的字符集，Unicode,Java用的就是这个字符集。
 Unicode有一些变种：UTF-8,UTF-16。

 一般来说，以后企业中开发推荐使用UTF-8。

***********************************************************/

★ <dfn>boolean</dfn>型。
	只有两个值：true或false。
	

true表示真；false表示假。

★ 类型转换
	所有数值型（7种）都可以自动转换
	▲ 自动转换：取值范围小的，可以自动转取值范围大的。
	     byte ➡ short(-32768~32767) ➡ <dfn>int</dfn> ➡ long ➡ float ➡ double
                                                                         ↗
			char(0~65535)
	推论：
	      - 所有整型，都可以自动转成浮点型。
	      - 所有整形，都可以自动转成long型。
	      - 所有数值型，都可以自动转成double型。

▲ 强制转换：
     上边反过来转换，就需要强制转换。
     （类型）

     - 浮点数转整数，始终是砍掉小数部分。
          - 强制转换，可能发生“溢出”。
    溢出规则：用该数-目标类型的大小*n。保证减出的差位于取值范围内。

▲ 表达式类型的自动提升：
     整个表达式的类型，与该表达式中最高等级的操作数的类型相同。

课堂练习：定义20个<dfn>int</dfn>型变量，分别用不同形式值。
	定义20个浮点型变量（分float和double）,分别用不同形式赋值。
	定义10个字符型变量，分别用不同形式赋值。

★ 运算符
	▲ 算术运算符（7个）

​     +，-，*，/，%
​     ++：将单个变量的值加一
​	放在变量之后，表示先用变量的值，再自加；
​	放在变量之前，表示先自加，再用变量的值。
​     --：将单个变量的值减一
​	放在变量之后，表示先用变量的值，再自减；
​	放在变量之前，表示先自减，再用变量的值。

​     对于一些更复杂的运算，应该使用Math类，该类提供了一些工具方法，可以完成初中，高中数学运算。

▲ 赋值运算符：=
    将 = 右边的值 转入左边的容器（变量）。

​    = 左边只能是变量。
​    = 右边可以是任何复杂的表达式。
​        大部分时候，= 右边往往都是复杂的表达式。

▲ 位运算符：
    它只对整型（byte,short,<dfn>int</dfn>,long,char(0~65535)）运算。
    针对二进制码进行运算。

​    负数的进制码：保存的是补码。
​    原码：直接算出来的叫原码，最高位，又叫符号位，0代表正数；1代表负数。
​    反码：除符号位之外，其他都按位取反。
​    补码：反码+1。

​    &：按位与。上下两位都是1时，得到的结果才是1.
​    |：  按位或。上下两位有一个是1时，得到的结果就是1。
​           当表示状态时，会用特定的数代表开关。
​           文本状态：粗体，斜体，下划线，中划线
​		1       2          4           8
​	               01      10        100       1000
​	粗体，斜体 00000011 = 1 | 2
​	粗体，斜体，中划线 00001011 = 1 | 2 | 8

​    "~"
​    "^"
​    "<<"
​    ">>"
​    ">>>"

★ 流程控制

- 顺序结构：从上到下，逐行执行
- 分支结构：根据具体情况，做出判断
- 循环结构，根据条件，让一个或多个步骤【重复】执行很多次

★ 顺序结构

​	不加任何控制，程序代码总是从上到下，依次执行

★ 分支结构

- if分支

  语法：

  ```java
  if(条件)
  {
  	//条件执行体
  }
  else if(条件)
  {
  	//条件执行体
  }
  ……
  else	//出现0~1次
  {
  
  }
  ```

  ▲ 两个注意点：

  - 如果条件执行体只有一条语句，条件执行体的花括号可以省略，如果省略了花括号，if条件只控制到紧跟if条件的第一个分号。
  - else - 否则，就是对前面条件取反。建议：if语句中有多个else if块，一定先处理范围小的条件。

- switch分支

  ```java
  switch(表达式)
  {
  	case 值1:	case块可出现0~N次
  		执行体
  	break;
  	
  	……
  	default:	default块可出现0~N次
  		执行体
  		break;
  }
  ```

  程序会计算switch表达式的值，表达式的值等于哪个case值，就执行哪个case块；如果都不等于，就执行default块。

  Java的switch不能处理范围！

  ▲ 两个注意点：

  - switch分支的表达式只能是byte，char，short，int，枚举，string（从Java7才行）这六个类型。
  - 如果不写break，会发生贯穿：Java会从第一个匹配的case块开始执行，再遇到break之前，直接忽略case值而执行每个case块的代码

- while循环

  语法：

  ```java
  [初始化语句]
  while(条件)
  {
  	//循环体
      [迭代语句]
  }
  ```

  程序判断循环条件，如果循环条件为true，执行循环条件；循环体执行完成后，再次判断循环条件，如果循环条件为true，执行循环体，直到最后一次判断，循环条件为false，结束循环。

  循环条件执行次数 == 循环体执行次数 + 1

  死循环：无限循环，永远不会停止的循环

  ▲ 注意点：
  
  - 如果循环体只有一条语句，循环体的花括号可以省略，如果省略了花括号，while条件只控制到紧跟while条件的第一个分号。
  
- do while循环

  语法：

  ```java
  do
  {
  	//循环体
  }while(条件);
  ```

  程序先执行一次循环体，循环体执行完成后，再次判断循环条件，如果循环条件为true，执行循环体，直到最后一次判断，循环条件为false，结束循环。

  循环条件执行次数 == 循环体执行次数

  特征：即使循环条件开始就是false，循环体也会执行一次

- for循环

  语法：

  ```java
  for([初始化语句] ; [循环条件] ; [迭代语句])
  {
  	//循环体
  }
  ```

  所有循环开始前，先执行初始化语句，只执行一次，程序判断循环条件，如果循环体为true，执行循环体，循环体执行完后，执行迭代语句，然后再次判断循环条件，如果循环条件为true，执行循环体

  - 注意点：
    - for循环中，只有两个分号是必须的，其他都是可以省略的，如果省略循环条件，循环条件永远都是true
    - 尽量不要在循环体内改变循环计数器的值
    - 初始化语句可以初始化多个变量，只要它们的数据类型相同即可，迭代语句也可有多条，多条迭代语句之间用逗号隔开即可
  
- break:

  结束循环，跳出循环。

  break可以带标签，用于结束标签所代表的循环

* continue:

  忽略本次循环continue后面的语句，重新开始执行下一次循环、

  所以，不带标签的continue语句，如果是循环体的最后一行，那是没有任何意义的。

  continue还可以带标签，用于忽略标签所代表的循环的剩下的语句，重新开始下一次标签所代表的循环

* return:

  结束方法

  循环总是位于方法中的，return既然可以结束方法，无论它在多深的循环里，都可以直接结束。

★ 数组(Array)：

​	数组：可以一次定义，就可以得到很多个类型相同，功能相似的变量。

​	数组其实就是一种引用类型。

​	任何已有的类型，添加一组方括号就变成数组类型。

​	数组元素的类型，是数组类型去掉方括号。

* 创建数组对象(数组初始化)

  * 静态初始化

    new类型[]{元素1，元素2，元素3，……}

    不指定长度，只指定每个元素。

    静态初始化简化语法：{元素1，元素2，元素3，……}。只能在定义数组变量指定初始值时使用！

  * 动态初始化

    new 类型[N]{}

    只指定长度，不指定元素。

★ 深入理解数组

​	数组是引用类型，引用类型和基本类型的区别在哪里？

​	[Java程序，必须要使用Java虚拟机<dfn>Vitual</dfn> Machine JVM才能运行]

​	Java程序的内存可分为：

* 堆（heap）内存：Java虚拟机启动时分配的一块永久的，很大的内存区，堆内存只有一块。
* 栈（stack）内存：每次方法运行分配一块临时，很小的内存区，每个方法都有自己对应的栈区，方法结束时，对应的栈区就会被回收。
* 在方法中定义的，局部变量（不管是什么类型），都放入对应的方法栈区。
* new出来的，都放在堆内存。
* 变量赋值的区别：
  * 基本类型的赋值，直接将该值存入变量所在内存。
  * 引用类型的赋值，将该对象所在第一个内存单元的编号（内存地址）存入变量。

★ 没有二维数组

* 其实只有一维数组，二维数组是假象。
* 二维数组的本质，是数组元素为一维数组的数组。

★ 面向对象：Java是一门面向对象的语言。

* 类：某一类对象的统称，相当于是一个概念性的(不是具体存在的东西)。

* 对象：现实中所能接触的各种"东西"。

* 总决：定义类，创建对象，调用方法。

* 定义类

  ```java
  [修饰符] class 类名
  {
  	//成员变量(field)
  	//方法(method)
  	//构造器(constructor)
  	//内部类(nested class)
  	//初始化块
  } --类体
  ```

* 类中五大成员

  * 修饰符：public，final，abstract，有且仅有
  * 类名：语法要求(只要是标识符即可)，从专业角度要求，多个单词连缀而成，每个单词首字母大写。

* 成员变量(field)

  ```java
  [修饰符] 类型 变量名 [=初始值]
  ```

  * 修饰符：private|protected|public，final，static，(transient：序列化相关)
  * 类型：任意基本类型或引用类型
  * 变量名：
    * 语法要求：只要是标识符即可
    * 专业角度要求：驼峰(camerlize)写法：首字母小写，后面每个单词首字母大写。
    * 成员变量：用于描述该类或对象的状态，因此通常建议用名词
    * 项目中，只定义项目感兴趣的状态。
  
* 方法(method)

  ```java
   	[修饰符] 返回值类型 方法名(形参列表)
      {
          //代码：定义变量(包括数组)，变量赋值，流程控制，数据语句
          如果声明了返回值类型，必须有return语句。
      } --方法体
  ```

  * 修饰符：private|protected|public，final | abstract，static
  * 返回值类型：任意基本类型或引用类型，可使用void声明没有返回值
  * 方法名：语法要求：只要是标识符即可；专业角度要求：驼峰写法；方法：用于描述该类或对象的行为，因此通常建议用动词；项目中，只定义项目感兴趣的行为
  * 形参列表：形参类型1 形参名1，形参类型2 形参名2，...；每个形参都满足“形参类型 形参名”的格式，多个形参之间用逗号隔开；代表调用方法时要传入的参数。

* 构造器(constructor)

  * 作用：new调用构造器来创建对象；如果没有为类写构造器，系统会默认为该类提供一个无参数的构造器

    ```java
    [修饰符] 构造器名(形参列表)
    {
    	//代码：定义变量(包括数组)，变量赋值，流程控制，数据语
    } --构造器体
    ```

  * 修饰符：private | protected | public

  * 构造器名必须与类名相同；判断一个类是否为构造器，要看两点：①，构造器名与类名相同；②，是否有返回值。

* 类可用于做什么

  * 定义变量；所有类都是引用类型，所有类都可用于声明变量
  * 调用static修饰方法或static修饰的变量
  * 创建对象：new 构造器(参数)
  * 派生子类

* 对象可用于做什么

  * 调用无static修饰的成员变量
  * 调用无static修饰的方法。
  
* 类是引用类型：

  * 数组也是引用类型
  * Java的引用类型非常多，无穷无尽....只要定义一个类，就多了一个引用类型
  * 引用类型的赋值，只是将对象的首地址存入变量中。

* this引用：

  * this可以出现在非static的方法，构造器中。作用如下：
    * 出现在非static方法中，this代表了该方法的调用者。谁调用该方法，this就代表谁
    * 出现在构造器中，this就代表改构造器正在初始化的对象。
    * this的很重要的作用是：用于区分方法或构造器的局部变量。尤其是与成员变量同名时--更需要使用this进行区分。
  
* 方法详解：

  * 方法的所属性：
    * 方法类似于函数，但与函数不同的是：方法不能独立存在，必须定义在类里面。
    * 定义在类中的方法，从逻辑上来看：
      * 如果该方法有static修饰，该方法属于类本身，应该用类调用
      * 如果该方法无static修饰，该方法属于对象本身
    * 方法不能独立执行，方法一定要有调用者，规则：
      * 如果调用同一个类中的方法，可以省略调用者，此时系统会添加默认的调用者
      * 如果该方法是无static修饰的方法，添加this作为默认的调用者
  * 形参个数可变的方法
    * 类型... 形参名：形参个数可变的方法，本质就是数组，等同于-类型[] 形参名
    * 类型... 写法的好处是：调用方法时更加方便，既可直接传入多个元素，系统会自动将他们封装成数组，也可用数组。
      * 写法的缺点是：类型... 这种写法只能作为形参列表的最后一个形参。
        * [暗示]：一个方法最多只能有一个"个数可变"的形参。

* 递归方法：

  * 方法里调用自身--递归带来了隐式循环

  * 要避免无限递归，一定要在可能出现某些情况下，不再调用方法自身

  * 假如：
    $$
    f(1) = 2
    f(2) = 5
    ...
    fZ(n) = f(n+2) - 2*f(n+1)
    要计算：f(10)是多少
    
    令 N = n + 2
    f(N-2) = f(N) - 2*f(N-1)
    f(N) = 2*f(N-1) + f(N-2)
    
    [难点]：要保证递归一定能出现递归结束的条件
    $$
  
* 方法重载(overload)：

  * 同一个类中，有多个同名的方法，但这多个方法的形参列表不同。口诀：两同一不同
  * <strong>修饰符不同不算重载，返回值类型不同也不算重载，当要确定一个方法时，仅有方法名是不够的，必须还要结合参数才能确定</strong>

* 方法的传参机制：

  * 如果定义方法时声明了形参，调用方法时必须传入对应的参数
  * Java的参数传递机制：
    * 值传递，传入的只是参数的副本，并不是参数本身
    * <strong>如果传递的参数是基本类型，方法中对参数所做的修改，完全不会影响参数本身</strong>
    * <strong>如果传递的参数是引用类型，参数的副本与参数本身指向同一个对象，因此方法通过参数副本修改对象时，会影响参数本身所指向的对象</strong>
  
* 变量详解：

  ```java
  									  ↗ 类变量：有static
  		↗ 成员变量(位置，类中定义成员变量)
  									  ↘ 实例变量：无static
  Java变量
  										↗ 形参
  		↘ 局部变量(位置：方法中定义局部变量) ➡ 普通局部变量
  										↘ 代码块的局部变量
  ```

  * 判断变量：
    * 首先看位置
    * 然后看有无static
  * 成员变量：可以不需要显式指定初始值，系统可以自动分配初始值：初始值规则与数组元素的初始值规则完全相同；程序中，类本身只有一个，程序一定先有类，再有对象(实例)！
    * 类变量：类变量属于类本身，当系统初始化时，就会为类分配空间，并执行初始化。
    * 实例变量：实例变量属于对象本身，系统每次创建对象时，都需要为该对象的实例变量分配空间，并执行初始化。
    * 严格来说：
      * 类变量应该由类本身进行访问
      * 实例变量应该由对象进行访问
    * <strong>Java垃圾语法：允许通过对象来访问类变量，但实际上，Java依然会将对象替换成对象所属的类。</strong>
  * 局部变量：必须由程序员显式指定初始值，然后才能使用--否则编译报错：可能尚未初始化变量xx；局部变量的作用域很小，只在方法里有效，离开了方法，局部变量立即失效；代码块的作用域很小，离开了代码块，代码块的局部变量就失效了。

★ 循环

嵌套：循环里再次放置循环，此时里层循环相当于外层循环的一条语句

​	    

```java
1         *				//空格4，星号1
2        ***			//空格3，星号3
3       *****			//空格2，星号5
4      *******			//空格1，星号7
5     *********			//空格0，星号9


         *				//空格3，星号1
        * *				//空格2，中间空格1
       *   *			//空格1，中间空格3
      *******			


	
         *				//输入数字5
        ***
       *****
      *******
     *********
      *******			//空格1，星号7 行数1
       *****			//空格2，星号5 行数2
        ***				//空格3，星号3 行数3
         *				//空格4，星号1 行数4


         *
        * *
       *   *
      *     *
     *       *
      *     *			//空格1 中空5 
       *   *			//空格2 中空3
        * *				//空格3 中空1
         *				//空格4 中空0
```

★ 使用<code>var</code>定义局部变量
    --从java 10开始才引入的特征，在Java9以前都是不行的。

使用<code>var</code>定义变量的语法是：

<code>var</code> 变量名 = 初始值

Java和JS绝对是不同的！
Java是强类型语言，每个变量总有固定的类型，指定类型的变量就只能装对应类型的值。

▲ <code>var</code>到底是什么？

​     <code>var</code>并不是关键字！<code>var</code>相当于一个动态类型。
​     <code>var</code>动态类型，将会由Java编译器根据变量【所赋的值】来推断其类型。

【结论】<code>var</code>并没有改变Java语言的本质，<code>var</code>只是一个简化写法。
             --无论你是何种类型的局部变量，最终都可直接使用<code>var</code>来声明。
             其类型由Java编译器根据变量【所赋的值】来推断其类型。

▲ 没有<code>var</code>行不行？<code>var</code>为什么引入？

​    不用<code>var</code>声明变量Java照样好好的，因此没有<code>var</code>完全不影响Java!
​    很多语言（<dfn>Kotlin</dfn>,JS等）都支持<code>var</code>定义变量，Java 10为了迎合普通开发者。
​    才引入一个<code>var</code>定义变量，对于Java的功能并没有任何影响 -- “语法糖”。

▲ 使用<code>var</code>有三个注意点：

​     A.<code>var</code>只能在方法中定义变量，不允许在类中定义成员变量。

​     B.<code>var</code>声明的变量，必须在声明时指定初始值。 --以后再赋值都不行了！
​        --如果不指定，编译器就无法推断变量的类型了！

​     C.<code>var</code>每次只能声明一个变量！<code>var</code>不允许在复合声明中使用。

▲ 使用<code>var</code>声明变量的优缺点：
     优点：编程更简洁，代码可以更整洁。
	

```java
String name = ……
int age = ……
CompanyName = ……
var name = ……
var age = ……
var CompanyName = ……
```

​     缺点：使用<code>var</code>声明变量，会降低程序的可读性。

▲ 何时不应该使用<code>var</code>声明变量？
	
	如果你声明变量时，为该变量指定了一个直观的初始值（5，“fkjava”,2.3）,此时		就可以使用var来声明变量。
	var age = 23;

​	尤其不应该的两处：
​	A.变量所赋的值是很复杂的方法调用，这样就导致它的返回值类型并不直观。
​	    
​     	    <code>var</code> a = def(<var>abc</var>().<var>xyz</var>()); //此时a的类型很难直观看出，因此就不应该使用<code>var</code>声明。
​	B.当你的变量的作用域很大时--方法很长，<code>var</code>变量影响很远。
​	   -- 不应该使用<code>var</code>声明。

★ 封装

* 封装，继承，多态--面向对象的三大特征

* 封装包含两方面的意思：

  * 隐藏：隐藏内部实现细节
  * 暴露：将一些操作界面暴露出来--如果通过暴露的界面来操作对象，该对象的内部状态不会被破坏。
  * 简而言之：封装要求合理隐藏，合理暴露

* 访问控制器：

  * private  ->  不写  ->  protected  ->  public
  * private(类访问权限)：该修饰符修饰的成员，只能在该类中访问。
  * 不写(包访问权限)：该修饰符修饰的成员，只能在该类及其该类所在的包中被访问
  * protected(子类访问权限)：该修饰符修饰的成员，只能在该类，及其该类所在包，该类的子类中被访问。
  * public(公共)：该修饰符修饰的成员可以在任意地方被访问
  * 指定原则：
    * 成员变量(实例变量)，通常用private修饰，为了隐藏实现细节。
    * 为每个成员变量提供public的getter,setter方法，用于控制该成员变量的方法。
    * 需要暴露的方法，通常用public修饰
    * 如果希望一个方法主要用于被子类重写，用protected修饰。

* 包

  不同公司完全可以定义同名的类，为了解决不同公司，不同项目的类名重复的问题，Java就引入“包”机制--就是在类名添加一个前缀

  * Java程序为类定义包
    * 在源代码中用package 包名;
    * 将生成的class文件放在对应的文件结构下
  * 包名的命名规则：
    * 语法要求：只要是标识符即可
    * 专业要求：推荐用公司域名倒写 . 再加上项目名
    * <strong style="color:red">【备注】：一旦为类指定了包名之后，使用该类时应该用完整类名：包名 + 类名</strong>
  
* 导入包

  * import的作用，为了省略写包名；如果不用import，每次用类时都需要使用包名加类名的形式。

  * import 包名.类名 --每次导入一个类
  * import 包名.* -- 导入指定包下的所有类；*只能代表类，包名不能用
  * Java程序默认已导入<code>Java.lang</code>报下所有类
  * 静态导入--import static
    * import的作用：为了省略写包名
    * import static的作用：可以省略写类名：用于导入指定类下的静态成员，导入之后，即可省略写类名
    * import static 包名.类名.静态成员名：每次只导入一个静态成员
    * import static 包名.类名.*：导入自定类下的所有静态成员
  * Java源程序的结构：
    * 一条package语句
    * N条import语句
    * N个class定义

* 构造器详解：

  * 构造器规则：
    * 构造器用于初始化对象
    * 构造器必须用new来用构造器，这样就也可以返回一个初始化完成的对象
    * 如果不为一个类提供构造器，系统会自动为该类提供无参数的构造器
  * 构造器重载：
    * 一个类中可以定义多个构造器(因此构造器名必然相同)，必须要求形参列表不同--这就是构造器重载。
    * this引用：this紧跟一个. 
    * this调用：this紧跟圆括号
    * this调用代表调用同一个类中重载的构造器--this调用只能出现在<strong style="color:red">构造器</strong>的<strong style="color:red">第一行</strong>
  
* 继承：

  * 封装，继承，多态--面向对象三大特征

  * 理解继承：

    * Java的继承：是一种“类与类”之间的关系
      * 是一种“由一般到特殊“的关系，子类是一种特殊的父类。
      * 子类实例，完全可以当成父类实例来使用
    * Java的继承，用的是”extends“：扩展的。
    * 父类(超类，基类，大类)；子类(派生类，小类)

  * 继承语法：

    * ```java
      [修饰符] class 类名 extends 父类
      {
      	
      }
      ```

  * 说明：

    * Java是单继承，只能有一个直接父类
    * 如果不显示继承父类，Java默认是继承Object类(JDK系统提供的类)
    * <strong style="color:red">一切都是Object</strong>
    * 继承的好处：代码复用
    * 子类继承父类，可以得到父类的：
      * 成员变量
      * 方法

* 方法重写(override)
  * 子类发现父类不适合自己时，就要重写父类的方法
  * 方法重写口诀：
    * 两同：方法名相同，形参列表相同
    * 两小：返回值类型相同或更小，声明抛出的异常相同或更小
    * 一大：访问权限相同或更大
  * @override：要求被修饰的方法必须重写父类方法，否则报错
  
* super限定：

  * 用于限定访问父类定义的实例变量或实例方法
  * 子类构造器调用父类的构造器
    * 子类构造器一定调用父类构造器一次 -- 有且仅有一次
      * 如果子类构造器没有显示调用父类构造器，系统会自动在子类构造器的第一行调用父类无参数的构造器
      * 子类构造器的第一行显式使用super调用来调用父类构造器；super调用一定是调用父类的构造器，只能出现在构造器的第一行；this调用是调用当前类的构造器，只能出现在构造器的第一行
      * <strong style="color:red">super调用和this调用不可能同时出现！</strong>
    * <strong style="color:red">如果父类没有无参数的构造器，子类的构造器必须显式调用(super调用)父类指定的构造器</strong>

* 多态：

  * 变态：同一个类型的实例，在执行同一个方法时，个别对象呈现出变异的行为特征

  * 多态：同一个类型的多个实例，在执行同一个方法时，呈现出多种的行为特征

  * 为什么有多态：

    * Java执行方法时，方法的执行是动态绑定的，方法总是执行该变量实际所指向对象的方法

  * 变量的类型：

    * 编译时类型：声明该变量时指定的类型；在Java程序的编译阶段，Java编译器只认编译时类型
    * 运行时类型(实际类型)：该变量实际引用的对象类型

  * 向上转型：子类对象可以直接赋值给父类变量(自动完成)

  * 强制转型(向下转型)：父类变量赋值给子类变量(强制转换)：(类型)变量名

  * 强制运算符的注意点：

    * 强制运算符只能在编译类型具有继承关系的变量之间进行强转，否则编译报错：不兼容的类型
    * 如果在编译类型具有继承关系的变量之间转换时，如果被转换变量的实际类型不是要转换的目标类型，程序就会引发`ClassCastException`(类型转换异常)

  * `instanceof`运算符：

    * 为了避免`ClassCastException`异常
  
* 当变量所引用的对象是后面类或子类的实例时，该运算符返回true
  
* <strong style="color:red">`instanceof`运算符只有在编译类型具有继承关系时才能进行判断，否则编译报错：不兼容的类型</strong>
  
* 初始化块：

  * ```java
    [修饰符]{
    	各种语句
    }
    ```
    
  * 初始化块是没有名字的

  * 修饰符只能出现一个：static

  * 实例初始化块

    * 无static
    * 实例初始化块是”假象“，一个类在编译之后，实例初始化块就会消失 -- 实例初始化块的代码会被还原到每个构造器的所有代码之前
    * 实例初始化块的作用：将多个构造器部分相同的代码提取到实例初始化块中
    * 实例初始化块何时执行：只要程序调用构造器创建对象，程序总会先执行实例初始化块 -- 因为实例初始化块被还原到每个构造器的所有代码之前

  * 定义实例变量时指定的初始值以是假象

    * 指定的初始值，编译之后就变成构造器所有代码之前的一条赋值语句
    * 实例初始化块的语句要还原到构造器所有代码之前；定义变量指定的初始值，也要还原到构造器的所有代码之前；这二者还原之后的顺序，按照它们在源代码中的顺序

  * 类初始化块

    * 有static
  
* 类初始化块：负责对类执行初始化
  
    * 当程序第一次主动使用该类时，系统会为该类分配内存空间，并执行初始化(调用类初始化块)；只要使用该类，基本都算主动使用 -- 除了仅使用类声明变量
    
* 类初始化块何时执行：程序第一次主动使用时，会执行该类的类初始化块；程序运行时，该类初始化块只执行一次
  
    * 定义类变量时指定的初始值也是假象：-- 指定的初始值，编译之后就变成类初始化中的一条赋值语句；但到底是在类初始化块的代码之前，还是代码之后，取决于它在源代码中的顺序
    
* <strong style="color:red">初始化任何类时，一定先从Object开始初始化，依次初始化它所有祖先类，最后才到它自己；创建任何对象时，一定是从Object构造器开始执行，执行完它所有祖先类的构造器，最后才执行它自己的构造器</strong>
  
* 包装类：

  * Java有八个基本类型：byte，short，<dfn>int</dfn>，long，float，double，char，<dfn>boolean</dfn>;这八个基本类型不能当成对象使用，而且也不能接受null值
  
      * | byte               | Byte      |
          | ------------------ | --------- |
          | short              | Short     |
          | <dfn>int</dfn>     | Integer   |
          | long               | Long      |
          | float              | Float     |
          | double             | Double    |
          | char               | Character |
          | <dfn>boolean</dfn> | Boolean   |
  
  * 自动装箱：基本类型的值可以自动当成包装类的实例使用
  
  * 自动拆箱：包装类的实例可以自动当成基本类型的值使用
  
  * <strong style="color:red">做项目时，建议使用包装类来声明变量</strong>
  
  * 包装类的方法：<dfn>parseXxx</dfn>：可以将字符串转成对应的基本类型值
  
  * <dfn>NumberFormatException</dfn>：要转的的字符串不符合数值格式
  
  * 当程序对Integer使用自动装箱时，它有一个缓存机制，它会缓存值在-128~127之间的对象。

* 两个要被重写的方法：
  * <dfn>toString()</dfn>方法
    * 程序打印对象，或把对象自动转成字符串时，实际上用的是该对象的<dfn>toString()</dfn>方法的返回值
    * 默认的<dfn>toString()</dfn>方法：Object提供的<dfn>toString</dfn>返回：类名@<dfn>hashCode</dfn>方法返回值
    * 重写<dfn>toString()</dfn>方法：返回该对象的内部状态
  * equals()方法
    * ==：如果判断两个引用变量，要求两个引用变量指向同一个对象才返回true值
    * 默认的<dfn>equals()</dfn>方法：Object提供的equals()方法，判断两个对象相等的标准与==完全一样
    * 重写equals()方法：根据业务规则来提供两个对象相等的标准
    * 实际项目中，用来作为equals比较的关键成员变量，通常并不需要使用全部的成员变量
  
* static
  * static并不是静态的意思，而是类的意思，有static修饰的成员属于类成员，否则属于实例成员
  * static不能修饰局部变量，因为局部变量不属于成员
  * static可修饰的成员：成员变量，方法，初始化块，内部类
  * java允许通过对象调用类成员，其实没有意义
  * static考点：
    * static成员不能访问非static成员
    * 非static成员可以访问static成员
  
* 单例模式(Singleton):

    * 设计模式：对于一批经常出现的设计场景，前人总结出来的比较成功的设计--这就是设计模式
    * 单例模式：在某些场景下，某些类只需要(只能)创建一个实例，比如系统的窗口管理器；数据库引擎访问点，Java程序所在的JRE环境
    * 如何设计单例模式：
        * 隐藏构造器--避免被创建实例
        * 暴露一个static方法
    
* final

    * 可以修饰变量(各种变量)，方法，类
    * final与abstract互斥
    * final修饰变量：该变量被赋值后，不能被重新赋值；final修饰的变量<strong style="color:red">必须</strong>被赋值，且只能赋值一次
    * final修饰成员变量
        * 非final的成员变量：程序可以不显式指定初始值，系统会为之分配默认初始值；初始值分配规则与数组元素初始值分配规则完全相同
        * final成员变量：程序员必须显式指定初始值
        * final实例变量：必须显式指定初始值，且只能在以下三个位置的其中之一指定：
            * 定义时指定初始值
            * 实例初始化块
            * 每个构造器显式指定一次初始值
            * 以上三个位置的本质其实都是：构造器
        * final类变量：必须显式指定初始值，且只能在以下两个位置的其中之一指定
            * 定义时指定初始值
            * 类初始化块
            * 以上两个位置的本质其实都是：类初始化块
        * final修饰局部变量：
            * 非final的局部变量，程序员必须先指定初始值，然后才能使用
            * final局部变量：程序员必须先指定初始值，然后才能使用，final局部变量不能被重新赋值
        * final修饰引用类型的变量
            * final只保证该引用变量本身不会被重新赋值，该变量所引用的对象完全可以被修改
        * final修饰的"宏替换"的变量：
            * 如果一个变量满足以下三个条件
                * 变量有final修饰
                * 声明变量时指定了初始值
                * 变量的初始值可以在编译时确定(初始值的表达式中没有变量，方法调用等)
                * 此变量会消失，所有出现该变量的地方，在编译时就会替换成该变量的值
    * final修饰方法：
        * 表明该方法不允许被子类重写
        * 该方法可以被重载，也可以被子类调用
        * private方法已经被隐藏在该类的内部，子类无法访问该方法，因此不可能被重写
        * final修饰private方法纯属多余，但java允许
    * final修饰类
        * 表明该类不能派生子类
    
* abstract(抽象)

    * 它只能修饰两个东西：方法和类
    * abstract和final互斥
    * 抽象类，有得有失
        * 抽象类与普通类的区别：有得有失
            * 有得：得到一个新功能：抽象类可拥有抽象方法
            * 有失：抽象类失去一个功能：创建对象
        * 抽象类的主要作用：派生子类
            * 子类构造器一定调用父类构造器一次，因此抽象类必须有构造器
    * 抽象方法：只有方法签名，没有方法体的方法
        * 一定要交给子类实现，否则不能调用
    * 抽象类的作用
        * 定义变量，只能用它子类的实例，向上转型
        * 调用类方法和类变量
        * 派生子类 -- 主要目的
    * 抽象类派生子类
        * 子类要么重写抽象父类中所有抽象方法，要么子类也只能是抽象的

* 接口：

    * 接口相当于一种彻底抽象的类

    * 接口体现的是一种规范 -- 要暴露出来供大家遵守，所以接口里所有东西都用public修饰

    * ```java
        [修饰符] interface 接口名 entends 父接口1 , 父接口2...
        {
        	//成员变量：只有常量，始终添加public static final修饰
        	//抽象方法：Java8之后，类方法，default方法(抽象添加方法体)
        	//内部类
        }
        ```

        * 默认方法：就是实例方法，它与原来的抽象方法地位相同
    
    * 接口是多继承的

    * 修饰符：public

    * 接口是彻底抽象的，不能有final，也不需要abstract修饰

    * 接口名：命名规范基本等同于类名

        * 接口一般推荐使用形容词
        
    * 接口的用处：
    
        * 定义变量，只能用实现类的实例来赋值(向上转型)
        * 调用类方法或变量
        * <strong style="color:red">派生实现类(子类)</strong>
    
    * Java 9 为接口增加的private方法
    
        * 语法：java9之后，接口中的private方法也可以定义方法体
        * 功能：如果在接口中定义了private方法，那么接口中至少有一个default()方法会调用该private方法；否则，该private方法就没有太大的意义
        * private方法的本质：工具方法，用于为接口中多个default方法(实例方法)提供支持
    
* 内部类：

    * 放在其它类的类体里定义的类，该类就属于内部类，包含内部类的类称为外部类
    * 内部类与顶层类的语法区别：
        * 内部类可以多如下修饰符：static，private，protected
        * 非静态内部类不能拥有静态成员 -- 除非是常量
        * 内部类可以直接访问外部类私有成员，但静态内部类不能访问外部类的非静态成员
    * 内部类的意义：当某个类的实例必须要依附另一个类的存在而存在，此时即可使用内部类；内部类可以提供更好的封装
        * 内部类的文件名：外部类$内部类.class
    * 区分变量：
        * 内部类直接访问外部类的成员变量
        * 但如果内部类的方法，内部类的成员变量与外部类的成员变量重名时，就需要进行如下划分
            * 外部类.this.实例成员

* 使用内部类：

    * 在外部类的里面使用静态内部类

        * 该内部类一定不能用private修饰
        * 在外部类的外面使用静态内部类 -- 只要把外部类当成静态内部类的包名即可

    * 声明变量

        * 外部类.静态内部类.变量名

    * 创建对象

        * new 外部类.静态内部类的构造器(参数)

    * 调用类方法或访问类变量

        * 外部类.静态内部类.类变量
        * 外部类.静态内部类.类方法(参数)

    * 派生子类

        * extends 外部类.静态内部类

    * 在外部类的外面使用非静态内部类

        * 内部类：也叫寄生类

            * static内部类的实例，要寄生在外部类类本身
            * 非static内部类的实例，要寄生在外部类的实例中

        * 外部类也叫宿主类

        * 声明变量：

            * 外部类.非静态内部类 变量名

        * 创建对象

            * 宿主.new 非静态内部类的构造器(参数)

        * 访问类变量(只能常量)

            * 外部类.非静态内部类.类变量

        * 派生子类

            * extends 外部类.非静态内部类

            * 重点在子类构造器的第一行，一定要用如下语法

            * ```java
                宿主对象.super(参数)
                ```

        * 非静态内部类(包括其子类)的实例的宿主是外部类的实例，因此必须由开发者先创建外部类实例作为宿主

* 匿名内部类

    * 匿名内部类：没有名字的类，因此在定义类时要立即创建实例，以后不能复用该类

    * 语法：

        * ```java
            new 父类构造器(参数)|接口()
            {
            	//类体部分：完全可以定义类的五大成员 -- 但构造器不行
            	//但通常来说，类体部分只是实现抽象方法
            }
            ```

        * 匿名内部类必须要显式继承父类或实现一个接口，不能同时实现多个接口，也不能继承父类并实现接口

        * 匿名内部类不能是抽象类，因此必须实现抽象父类或接口中所有抽象方法

* Java的入口方法：

    * ```
        public static void main(String[] args)
        --该方法由JVM负责调用
        
        -String[] args -- 这个数组用于接收用户输入的参数
        ```

* Scanner

    * 获取各种输入
    * nextXxx(): 获取下一个整数，浮点数，行......

* System 与 Runtime

    * 要获取操作系统相关的属性，通过System

    * 要获取JVM环境相关的信息，通过Runtime

    * System的类变量：

        * in：代表键盘
        * out：代表屏幕
        * System的所有方法都是类方法，因此无需创建实例
        * currentTimeMillis()：获取当前时间。从1970年月1日0时0分0秒到现在经过了多少毫秒
        * exit(int status)：退出JVM
        * getenv()：获取所有环境变量
        * getenv(String name)：获取指定环境变量
        * getProperties()：获取所有系统属性
        * getProperty(String name)：获取指定系统属性

    * Runtime代表JVM运行时环境

        * Runtime只需要一个实例，应该采用单例模式

        * ```java
            static Runtime getRuntime() //用于获取RunTime的单例对象。
            ```

        * freeMemory()：空闲堆内存

        * maxMemory()：最大堆内存

        * totalMemory()：总是用堆内存

        * exec(String commond)：运行操作系统上的程序

* Object

    * 它是一切类的父类
    * 通常有三个需要被重写的方法
    * toString()：返回该对象的描述字符串
    * equals(Object obj)：根据业务规则，提供判断两个对象相等的标准
    * hashCode()

* Objects

    * Arrays：操作数组的工具类
    * Objects：操作对象的工具类，该类的工具方法可以避免NullPointerException

* 字符串

    * Java的字符串有三个：
        * String：代表了字符内容不能改变的字符串
        * StringBuffer：代表字符内容可变的字符串，它是线程安全的，性能较差
        * StringBuilder：代表字符内容可变的字符串，线程不安全，性能较好

* Math：

* Random和ThreadLocalRandom

    * Random是普通的随机数生成器
    * ThreadLocalRandom是当前线程的随机数生成器

* BigDecimal：精确小数

    * 对于float，double两个类型而言，它们保存的小数可能不精确--所有语言都是这样。
    * 因此如果要比较两个浮点数是否相等，通常计算它们的差，如果差小于一个极小的数，即可认为它们相等。如果确实需要精确保存小数的值，就需要使用BigDecimal。

* Date：代表日期时间

    * Date大部分构造器，方法都已经过时了
    * Date()：获取当前时间
    * Date(long date)：负责将currentTimeMillis()返回的long型时间转换成Date对象
    * getTime()：返回long型的时间(获取currentTimeMillis()所返回的时间)

* Calendar：代表日期时间

    * 被设计出来取代Date的
    * Calendar采用了模板设计，Calendar是一个抽象类，因此实际使用的通常是子类。
    * 原本是希望世界上不同的日历都继承Calendar来派生子类
    * Java为Calendar提供了一个子类：GregorianCalendar：公历
    * 获取实例
        * Calendar.getInstance()
    * 获取指定字段(年，月，日....)的值：对象.get(Field名)
    * 设置指定字段(年，月，日....)的值：对象.set(Field名，值)
        * mutable：可变的
        * immutable：不可变的
    * 在指定字段(年，月，日....)上添加值：对象.add(Field名，值)
    * getTime()：该方法用于获取该Calendar对应的Date对象。

* Lambda表达式

    * 函数式接口：只有一个抽象方法的接口

    * @Functional Interface：用于修饰函数式接口

    * Lambda表达式：本质就是函数式接口的匿名内部类

        * 只保留匿名内部类中所实现的抽象方法的参数列表和方法体部分，并在参数列表和方法体之间用箭头隔开。

    * Lambda表达式的简化

        * 通常来说，写形参列表时都省略形参类型
        * 如果形参列表只有一个参数，形参列表的圆括号可以省略
        * 如果方法体只有一条代码，方法体的花括号可以省略
        * 如果方法体只有一条代码，且这条代码是return语句，那么可以省略return关键字

    * Lambda表达式的方法引用和构造器引用 -- 只有当方法体只有一条代码时才可使用 -- 本质是：进一步省略：完全省略形参列表和箭头

        * 引用类方法

            * (参数列表) -> 某个类.某个方法(参数列表);
            * 某个类::某个方法;

        * 引用实例方法

            * (参数1 , 其他参数) -> 参数1.某个方法(其他参数);
            * 参数1的类型::某个方法;

        * 引用特定对象的实例方法

            * (参数列表) -> 某个对象.某个方法(参数列表);
            * 某个对象::某个方法;

        * 构造器引用

            * (参数列表) -> new 构造器(参数列表);
            * 类名::new;
    
* 枚举

  * 现实生活中，很多类的实例是固定的，开发者不能随便创建实例
  
  * 枚举是实例数量已经固定的类
  
      * 枚举可以很方法的实现单例模式
  
  * 语法格式
  
      * ```java
          [public] enum 枚举名
          {
          	//第一行列出所有实例 -- 枚举以后就只能使用这些实例
          	//同样可以定义类的五大成员
          }
          ```
  
  * 与普通类的语法区别：
  
      * 枚举默认已经继承了<dfn>Enum类</dfn>(Object子类),因此枚举不能继承其他类
      * 枚举类默认要么是final类，要么是抽象类
      * 如果枚举类没有抽象方法，系统自动添加final；如果添加了抽象方法，系统自动添加abstract
      * final，abstract不允许显式添加
      * 枚举类的构造器只能是private修饰，(系统自动添加private修饰)
      * 枚举要求在第一行列出所有实例
  
  * 定义枚举之后，枚举默认拥有如下方法
  
      * static 类名[] values()：该方法返回所有的枚举实例
      * static 类名 <dfn>valuesOf</dfn>(String name)：该方法根据枚举名返回枚举实例
      * String name()：该方法返回枚举实例的名字
      * <dfn>int</dfn> ordinal()：该方法返回枚举实例的序号
  
  * 枚举可用于：
  
      * 定义变量
      * 调用方法或者类变量
      * switch表达式的类型可以是：byte、short、<dfn>int</dfn>、String、枚举
  
  * 枚举与构造器
  
      * 枚举的第一行：并不是简单地列出枚举实例
      * 第一行实际上要创建，并列出枚举类的所有实例 -- 因此需要根据构造器来传入对应的参数
      
  * 抽象枚举
  
      * 枚举可以是抽象的
      * 只要定义了抽象方法，系统会自动为该枚举添加abstract修饰
      * 如果枚举是抽象的，那就需要在第一行用匿名内部类语法创建枚举实例
  
  * 枚举实现接口
  
      * 枚举可以实现接口
      * 必须实现接口中所有抽象方法
      * 如不实现接口中所有抽象方法，此时就变成了一个抽象枚举 -- 需要在第一行用匿名内部类语法创建枚举实例

* Java修饰符的适用范围
  * 3：三种类型：类、接口、枚举
  * 4：四个修饰符
  * 5：五大成员
  * 传统：private | protected | public、static、final、abstract
  * 多线程：synchronized、volatile
  * 序列化：transient
  * native：修饰方法，用于使用C/C++调用底层平台的API来实现该方法
  * <dfn>strictfp</dfn>：严格浮点数，可修饰类、接口、枚举、方法，用于保证Java会严格按照浮点数的规范来计算
  
* jar命令
  * 对于实际的Java项目部署时，通常都会打包成”压缩包(归档文件)“
  * 在Java领域中，通常有如下三种压缩包(格式完全一样，只是后缀不同)
    * jar：就是很多class文件的压缩包，最常见的一种
    * war：完整web应用的压缩包
    * ear：通常是企业级项目的压缩包，一般会包括EJB的jar包和Web部分的war包

  







